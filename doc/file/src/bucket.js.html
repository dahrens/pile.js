<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/bucket.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/ahrensde/pile.js.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/bottom.js~LocalStorageBottom.html">LocalStorageBottom</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/bottom.js~RedisBottom.html">RedisBottom</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/bucket.js~Bucket.html">Bucket</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/dumpster_diver.js~DumpsterDiver.html">DumpsterDiver</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/mediator.js~Mediator.html">Mediator</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/bucket.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&quot;use strict&quot;;

import EventEmitter from &apos;events&apos;;
import { generate } from &apos;shortid&apos;;
import { Mediator } from &apos;src/mediator&apos;;


/**
 * Appends a &apos;s&apos; to the given string.
 */
function pluralize(s) { return s + &apos;s&apos;; }


/**
 * Resolves the modelName from in _id (persistence id).
 */
function modelNameFromId(_id) {
    let modelName = _id.split(&apos;:&apos;)[0];
    if (!modelName) {
        throw &quot;No known modelName found in _id: &quot; + _id;
    }
    return modelName
}

/**
 * Buckets are used to create your overall pile.
 * Use them to cluster your objects together.
 *
 * Buckets store data in a flat manner.
 */
export class Bucket extends EventEmitter {
  constructor(redis) {
      super();
      this.memory = new Map();
      this.models = {}
  }

  /**
   * Registers a cls for this Bucket.
   *
   * This means that the Bucket is able to persist those objects
   * into his own Namespace as seperate objects.
   */
  register(cls) {
      let instance = new cls();
      if (!(instance instanceof Mediator)) {
        throw &quot;Must be a subclass of Mediator&quot;
      }
      this.models[instance.model] = cls
  }

  unregister(cls) {
      throw &quot;to be done...&quot;
  }

  _modelFromModelName(modelName) {
      let model = this.models[modelName]
      if (!model) {
        throw &quot;No model class found for modelName: &quot; + modelName;
      }
      return model
  }

  _modelFromId(_id) {
      return this._modelFromModelName(
        modelNameFromId(_id)
      );
  }

  /**
   * Asynchronous getter for mediators known by the Bucket.
   *
   * Error are handled in the callback method, that *must* be
   * provided if you want to receive a result.
   */
  get(_id, callback) {
      if (typeof _id !== &quot;string&quot;) {
        throw &quot;Must be a string&quot;
      }
      var model = this._modelFromId(_id);
      let me = this;
      if (this.map.has(_id)) {
        callback.call(me, null, this.memory.get(_id)); return;
      } else {
        this.redis.hgetall(_id, function(err, reply) {
          if (!reply) {
            callback.call(me, &quot;Not found id &quot; + _id, null);
          } else {
            me._add(new model(reply), false)
            callback.call(me, null, me.memory.get(_id));
          }
        });
      }

  }

  /**
   * Adds one or more mediators to the Bucket.
   */
  add(mediators) {
    let arr = Array.isArray(mediators) ? mediators : [mediators]
    for (var i in arr) { this._add(arr[i]); }
  }

  /**
   * Adds one object to the Bucket.
   */
  _add(mediator) {
      var me = this;
      if (!(mediator instanceof Mediator)) {
        throw &quot;Must be a subclass of Mediator&quot;;
      } else {
        mediator._bucket = me
        me.map.set(mediator._id, mediator);

        let alloy = this._flatten(mediator)
        for (var i = 0; i &lt; alloy.length; i++) {
          me._persist(alloy[i]);
        }

        mediator.on(&quot;changed&quot;, function(mediator, oldData) {
          let alloy = _flatten(mediator)
          for (var i = 0; i &lt; alloy.length; i++) {
            me._persist(alloy[i]);
          }
        })
      }
  }

  /**
   * Removes one or more objects from the Bucket.
   *
   * You can pass an id or an mediator or a list of both, mediators
   * and ids to this method.
   */
  remove(mediators) {
    let arr = Array.isArray(mediators) ? mediators : [mediators]
    for (var i in arr) { this._remove(arr[i]); }
  }

  /**
   * Removes one object from the bucket, either by id or mediator object.
   */
  _remove(mediator) {
    if (typeof mediator !== &quot;string&quot; &amp;&amp; !(mediator instanceof Mediator)) {
      throw &quot;Must be a subclass of Mediator or an id.&quot;;
    }
    let _id = (typeof mediator === &quot;string&quot;) ? mediator : mediator._id;
    let model = modelNameFromId(_id);
    this.map.delete(_id);
    this.redis.srem(pluralize(model), _id);
    this.redis.del(_id);
  }

  _flatten(mediator) {
    let mediators = [];
    let ret = [mediator._id]
    let junctions = [];
    let props = {};
    for (let prop in mediator.data) {
      if (mediator[prop] instanceof Mediator) {
        props[prop] = mediator[prop]._id;
        this.add(mediator[prop]);
        this.junctions
      } else {
        props[prop] = mediator[prop];
      }
    }
    ret.push(props);
    mediators.push(ret);
    return mediators
  }

  _persist(obj) {

    // TODO: there might by duplicates - depending on your models very many and usage may be very many - lets filter them out before proceeding here...
    //this.redis.hmset(obj._id, props);
  }

  _read() {}
}


/**
 * Those were managed behind the scene by a Bucket.
 * For each junction between two Meditors there
 * will be a Junction available.
 */
class Junction {
  constructor() {}
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.5)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
